package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.43

import (
	"context"

	"github.com/antch57/goose/graph/model"
	"github.com/antch57/goose/internal/albums"
	"github.com/antch57/goose/internal/bands"
	"github.com/antch57/goose/internal/db"
	"github.com/antch57/goose/internal/songs"
)

// CreateBand is the resolver for the createBand field.
func (r *mutationResolver) CreateBand(ctx context.Context, name string, genre string, year int, albums []*model.AlbumInput, description *string) (*model.Band, error) {
	tx, err := db.Transacntion()
	if err != nil {
		// TODO: better error handling
		return nil, err
	}

	band, err := bands.CreateBand(name, genre, year, albums, description, tx)
	if err != nil {
		return nil, err
	}
	return &band, nil
}

// CreateAlbum is the resolver for the createAlbum field.
func (r *mutationResolver) CreateAlbum(ctx context.Context, bandID string, title string, releaseDate string, songs []*model.SongInput) (*model.Album, error) {
	tx, err := db.Transacntion()
	if err != nil {
		// TODO: better error handling
		return nil, err
	}

	commitTransaction := true
	album, err := albums.CreateAlbum(bandID, title, releaseDate, songs, tx, commitTransaction)
	if err != nil {
		return nil, err
	}
	return album, nil
}

// CreateSong is the resolver for the createSong field.
func (r *mutationResolver) CreateSong(ctx context.Context, bandID string, albumID *string, title string, duration int) (*model.Song, error) {
	tx, err := db.Transacntion()
	if err != nil {
		// TODO: better error handling
		return nil, err
	}

	commitTransaction := true
	song, err := songs.CreateSong(bandID, *albumID, title, duration, tx, commitTransaction)
	if err != nil {
		return nil, err
	}
	return song, nil
}

// DeleteBand is the resolver for the deleteBand field.
func (r *mutationResolver) DeleteBand(ctx context.Context, bandID string) (bool, error) {
	// TODO: prepared statements?
	res, err := bands.DeleteBand(bandID)
	if err != nil || !res {
		return false, err
	}
	return true, nil
}

// DeleteAlbum is the resolver for the deleteAlbum field.
func (r *mutationResolver) DeleteAlbum(ctx context.Context, albumID string) (bool, error) {
	// TODO: prepared statements?
	res, err := albums.DeleteAlbum(albumID)
	if err != nil || !res {
		return false, err
	}
	return true, nil
}

// DeleteSong is the resolver for the deleteSong field.
func (r *mutationResolver) DeleteSong(ctx context.Context, songID string) (bool, error) {
	// TODO: prepared statements?
	res, err := songs.DeleteSong(songID)
	if err != nil || !res {
		return false, err
	}
	return true, nil
}

// Bands is the resolver for the bands field.
func (r *queryResolver) Bands(ctx context.Context) ([]*model.Band, error) {
	// TODO: prepared statements?
	bands, err := bands.GetBands()
	if err != nil {
		return nil, err
	}
	return bands, nil
}

// Band is the resolver for the band field.
func (r *queryResolver) Band(ctx context.Context, id string) (*model.Band, error) {
	// TODO: prepared statements?
	band, err := bands.GetBand(id)
	if err != nil {
		// TODO: better error handling
		return nil, err
	}
	return band, nil
}

// Album is the resolver for the album field.
func (r *queryResolver) Album(ctx context.Context, id string) (*model.Album, error) {
	// TODO: prepared statements?
	album, err := albums.GetAlbum(id)
	if err != nil {
		// TODO: better error handling
		return nil, err
	}
	return album, nil
}

// Song is the resolver for the song field.
func (r *queryResolver) Song(ctx context.Context, id string) (*model.Song, error) {
	// TODO: prepared statements?
	song, err := songs.GetSong(id)
	if err != nil {
		// TODO: better error handling
		return nil, err
	}
	return song, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
